### Statement

Реализуйте спинлок.
      

Напишите на языке ассемблера x86 функции с такими сигнатурами:


```
void spin_lock(volatile int *s);
void spin_unlock(volatile int *s);
```
      
Пользователи будут вызывать эти функции, чтобы создать в коде
      критическую секцию с активным ожиданием:


```
int s = 0;
...
spin_lock(&s);
// critical section here
spin_unlock(&s);
```
      
Тестирующая программа запускает с помощью `fork()` 10 процессов,
    которые конкурируют за спинлок в общем участке памяти.
      

(Идея: попробуйте сделать две реализации, одну с помощью
      инструкции xchg, а другую с помощью cmpxchg, и сравните ощущения.)
      

<details>
<summary>
Про спинлок и атомики (если для решения зачем-то использовался компилятор):
        
</summary>
По умолчанию для всех операций с атомарными переменными используется `memory_order_seq_cst`.
        Это наиболее сильный порядок (в частности, **все** seq_cst операции линейно упорядочены).
        Для корректности спинлока (упорядочивания критических секций) достаточно использовать семантику acquire/release (`memory_order_acquire` / `memory_order_release`).
        
В зависимости от используемого memory_order компилятор может генерировать разные инструкции для одной и той же атомарной операции, чтобы обеспечить требуемые гарантии.
        
Подробнее про memory_order можно почитать на cppreference ([C](https://en.cppreference.com/w/c/atomic/memory_order), [C++](https://en.cppreference.com/w/cpp/atomic/memory_order)) или [в конспекте](https://github.com/blackav/hse-caos-2020/tree/master/22-mutex#memory_order).
      

    
</details>

